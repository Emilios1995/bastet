{1:top Ocaml_abstract}

{i Ocaml_abstract} is a ReasonML/Ocaml library for category theory and abstract algebra. The entry
point of this library is the module: {!Ocaml_abstract}.

{2 Project Layout}

{ul
{- {!Ocaml_abstract.Interface} provides the category theory and abstract algebra interfaces.}
{- {!Ocaml_abstract.Verify} provides property based tests to verify that implementations are
lawful.}
{- {!Ocaml_abstract.Infix} provides functors to generate infix operators for the interfaces.
Implementations in this library already have instantiated infix submodules for convenience.}
{- {!Ocaml_abstract.Default} provides default implementations for interface functions.}
{- {!Ocaml_abstract.Functors} provides already instantiated functors for common data combinations
for convenience.}
{- {!Ocaml_abstract.Functions} provides generic functions that are built on top the abstract
interfaces.}
{- {!Ocaml_abstract.PPX_Let} privides helpers for integrating with the
{{:https://opam.ocaml.org/packages/ppx_let}ppx_let} package.}
{- {!Ocaml_abstract.Test} provides generic tests that can be combined with any frontend or backend
unit and generative test framework.}
}

There are also implementations for these builtin Ocaml data types:

{ul
{- {!Ocaml_abstract.Array} }
{- {!Ocaml_abstract.Bool} }
{- {!Ocaml_abstract.Dual} }
{- {!Ocaml_abstract.Endo} }
{- {!Ocaml_abstract.Float} }
{- {!Ocaml_abstract.Function} }
{- {!Ocaml_abstract.Int} }
{- {!Ocaml_abstract.List} }
{- {!Ocaml_abstract.Option} }
{- {!Ocaml_abstract.String} }
{- {!Ocaml_abstract.Tuple} }
{- {!Ocaml_abstract.Result} }
}


{2 Who is this for? }

This library is intended for those who want to write highly reusable functional code. Category
theory and abstract algebra is a perfect foundation for this because of functional programming's
close relationship with pure math — functions in this context are closer to the mathematical sense
of the word rather than something like a subroutine. 

But unless your entire team is already familiar with these principles, it's recommended that library
authors provide a {i concrete} API that doesn't expose this level of abstraction for newcomers.

For example, consider this abstraction that generalizes the notion of something similar to the
{!Ocaml_abstract.Result.hush} function but instead returns a [unit] type for the second type
argument instead of an {!option} type:

{[
{{&Hush}}
]}

In this example, the (abstract) [Hush] functor would be exposed to other library authors while the
(concrete) [hush] function with some docs would be exposed only to the newcomers.

This way anyone can still take advantage of the {i free} implementations provided by this
abstractions without any of the learning curve — they can just read the type signature of the [hush]
function and none of the other stuff. And if need be, the functor here could be reused for some
other type that takes two parameters, such as a tuple, map, or record.



{2 A Brief Introduction }

The downside to using such abstractions is that newcomers are often overwhelmed. They might not know
how much category theory or abstract algebra they need to formally know (almost none), or whether or
not to read monad tutorials (you shouldn't). The best way to learn this stuff is to read the [module
type]s and the laws that the types need to satisfy.

{3 Monoids }

{i - "A monad is just a monoid in the category of endofunctors, what's the problem?" }

{4 Monoid }

Int, String

{[
{{Monoid}}
]}

{4 Plus }

list, array, option

{4 Monad }

option

{4 Category }

function

{3 Comparison }

{4 Eq }
{4 Ord }


{3 Rings }

{4 Euclidean Ring }

int, float


{3 Lattices }

{4 Join Semilattice }

propagators

{4 Heyting Algebra }

fuzzy logics

{4 Boolean Algebra }

bool



{2 PPX Let }

You can integrate monads with {{:https://opam.ocaml.org/packages/ppx_let}ppx_let}, a ppx rewriter
that provides {e do notation} sugar for {!Ocaml_abstract.Interface.MONAD}s. The rewriter expects a
[Let_syntax] module to be in scope, which you can construct using [PPX_Let.Make], like so:

{[
# #require "fmt";;
# module OptionLet = PPX_Let.Make(Option.Monad);;
# let add_optionals = fun x y ->
    let open OptionLet in
    let%bind x' = x in
    let%bind y' = y in
    Some (x' + y');;
# Fmt.pr "%a" (Fmt.option Fmt.int) @@ add_optionals (Some 123) (Some 456);;
- : int option = Some 579
]}

For bucklescript there is the {{:https://github.com/reasonml-labs/bs-let}bs-let} library.


{2 Background}

The initial inspiration for the library came from a [sequence]
{{:https://gist.github.com/Risto-Stevcev/ecfa56d9e87c58a3c20127393c6f283f}demo} on the FP slack by
{{:https://github.com/rightfold}rightfold (Chloe)} on how to simulate higher kinded types in Ocaml.

Other category theory libraries for Ocaml at the time used the uglier
[HKT<>]/[HKT2<>]/[TyCon]/[TyCon2] hacks that are prevalent in other languages that lack higher
kinded types. They also lacked a lot of features.

The realization was that there was a better way and that it was possible to write a {i clean}
interface in Ocaml using local opens, functors, and avoiding monoid instances for containerized
types like [list] and [array] and using [alt] instead, since these types are monoids in the category
of functors.
