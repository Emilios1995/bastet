<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ocaml_abstract.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ ocaml_abstract</nav><nav class="toc"><ul><li><a href="#top">Ocaml_abstract</a><ul><li><a href="#project-layout">Project Layout</a></li><li><a href="#ppx-let">PPX Let</a></li><li><a href="#background">Background</a></li></ul></li></ul></nav></header><h2 id="top"><a href="#top" class="anchor"></a>Ocaml_abstract</h2><p><i>Ocaml_abstract</i> is a ReasonML/Ocaml library for category theory and abstract algebra. The entry point of this library is the module: <a href="Ocaml_abstract/index.html"><code>Ocaml_abstract</code></a>.</p><h3 id="project-layout"><a href="#project-layout" class="anchor"></a>Project Layout</h3><ul><li><a href="Ocaml_abstract/Interface/index.html"><code>Ocaml_abstract.Interface</code></a> provides the category theory and abstract algebra interfaces.</li><li><a href="Ocaml_abstract/Verify/index.html"><code>Ocaml_abstract.Verify</code></a> provides property based tests to verify that implementations are lawful.</li><li><a href="Ocaml_abstract/Infix/index.html"><code>Ocaml_abstract.Infix</code></a> provides functors to generate infix operators for the interfaces. Implementations in this library already have instantiated infix submodules for convenience.</li><li><a href="Ocaml_abstract/Default/index.html"><code>Ocaml_abstract.Default</code></a> provides default implementations for interface functions.</li><li><a href="Ocaml_abstract/Functors/index.html"><code>Ocaml_abstract.Functors</code></a> provides already instantiated functors for common data combinations for convenience.</li><li><a href="Ocaml_abstract/Functions/index.html"><code>Ocaml_abstract.Functions</code></a> provides generic functions that are built on top the abstract interfaces.</li><li><a href="Ocaml_abstract/PPX_Let/index.html"><code>Ocaml_abstract.PPX_Let</code></a> privides helpers for integrating with the <a href="https://opam.ocaml.org/packages/ppx_let">ppx_let</a> package.</li></ul><p>There are also implementations for these builtin Ocaml data types:</p><ul><li><a href="Ocaml_abstract/Array/index.html"><code>Ocaml_abstract.Array</code></a></li><li><a href="Ocaml_abstract/Bool/index.html"><code>Ocaml_abstract.Bool</code></a></li><li><a href="Ocaml_abstract/Dual/index.html"><code>Ocaml_abstract.Dual</code></a></li><li><a href="Ocaml_abstract/Endo/index.html"><code>Ocaml_abstract.Endo</code></a></li><li><a href="Ocaml_abstract/Float/index.html"><code>Ocaml_abstract.Float</code></a></li><li><a href="Ocaml_abstract/Function/index.html"><code>Ocaml_abstract.Function</code></a></li><li><a href="Ocaml_abstract/Int/index.html"><code>Ocaml_abstract.Int</code></a></li><li><a href="Ocaml_abstract/List/index.html"><code>Ocaml_abstract.List</code></a></li><li><a href="Ocaml_abstract/Option/index.html"><code>Ocaml_abstract.Option</code></a></li><li><a href="Ocaml_abstract/String/index.html"><code>Ocaml_abstract.String</code></a></li><li><a href="Ocaml_abstract/Tuple/index.html"><code>Ocaml_abstract.Tuple</code></a></li><li><a href="Ocaml_abstract/Result/index.html"><code>Ocaml_abstract.Result</code></a></li></ul><h3 id="ppx-let"><a href="#ppx-let" class="anchor"></a>PPX Let</h3><p>You can integrate monads with <a href="https://opam.ocaml.org/packages/ppx_let">ppx_let</a>, a ppx rewriter that provides <em>do notation</em> sugar for <a href="Ocaml_abstract/Interface/module-type-MONAD/index.html"><code>Ocaml_abstract.Interface.MONAD</code></a>s. The rewriter expects a <code>Let_syntax</code> module to be in scope, which you can construct using <code>PPX_Let.Make</code>, like so:</p><pre><code class="ml"># #require &quot;ocaml_abstract&quot;;;
# #require &quot;fmt&quot;;;
# open Ocaml_abstract;;
# module OptionLet = PPX_Let.Make(Option.Monad);;
# let add_optionals = fun x y -&gt;
    let open OptionLet in
    let%bind x' = x in 
    let%bind y' = y in
    Some (x' + y');;
# Fmt.pr &quot;%a&quot; (Fmt.option Fmt.int) @@ add_optionals (Some 123) (Some 456);;
- : int option = Some 579</code></pre><p>For bucklescript there is the <a href="https://github.com/reasonml-labs/bs-let">bs-let</a> library.</p><h3 id="background"><a href="#background" class="anchor"></a>Background</h3><p>The initial inspiration for the library came from a <code>sequence</code> <a href="https://gist.github.com/Risto-Stevcev/ecfa56d9e87c58a3c20127393c6f283f">demo</a> on the FP slack by <a href="https://github.com/rightfold">rightfold (Chloe)</a> on how to simulate higher kinded types in Ocaml.</p><p>Bucklescript had released v1 at the time and ReasonML was announced. I was initially interested because of Facebook's backing of ReasonML, which I felt would popularize the language enough to built a robust ecosystem that Purescript was lacking. That turned out to be true.</p><p>As someone coming from Purescript, I realized that I could get a lot of the stuff I liked from that ecosystem in a language that was much easier for an average developer to learn due to Ocaml's much simpler type system and explicitness, while still getting all of the benefits of the ML family of languages. Ocaml also ran effects without the <code>IO</code> type by default, which meant that working with the JS FFI was much more pleasant because side-effects wouldn't have to be threaded through IO. And since both mutation and OO programming were also supported, it meant that it could reach developers that weren't even familiar with FP. Onboarding was no longer an excuse not to use the language.</p><p>Other category theory libraries for Ocaml at the time used the uglier <code>HKT&lt;&gt;</code>/<code>HKT2&lt;&gt;</code>/<code>TyCon</code>/<code>TyCon2</code> hacks that are prevalent in other languages that lack higher kinded types. They also lacked a lot of features.</p><p>The realization was that there was a better way and that it was possible to write a clean interface in Ocaml using local opens, functors, and avoiding monoid instances for containerized types like <code>list</code> and <code>array</code> and using <code>alt</code> instead, since these types are monoids in the category of functors. Ultimately, I wanted to leverage what I had learned from Haskell and Purescript while also considering the practical aspects like the learning curve, and so this library was born.</p></div></body></html>